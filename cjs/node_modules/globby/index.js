"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDynamicPattern = exports.globbySync = exports.globbyStream = exports.globby = exports.generateGlobTasksSync = exports.generateGlobTasks = exports.convertPathToPattern = void 0;
Object.defineProperty(exports, "isGitIgnored", {
  enumerable: true,
  get: function () {
    return _ignore.isGitIgnored;
  }
});
Object.defineProperty(exports, "isGitIgnoredSync", {
  enumerable: true,
  get: function () {
    return _ignore.isGitIgnoredSync;
  }
});
require("core-js/modules/esnext.async-iterator.filter.js");
require("core-js/modules/esnext.async-iterator.flat-map.js");
require("core-js/modules/esnext.async-iterator.map.js");
require("core-js/modules/esnext.async-iterator.some.js");
require("core-js/modules/esnext.iterator.constructor.js");
require("core-js/modules/esnext.iterator.filter.js");
require("core-js/modules/esnext.iterator.flat-map.js");
require("core-js/modules/esnext.iterator.map.js");
require("core-js/modules/esnext.iterator.some.js");
require("core-js/modules/esnext.set.add-all.js");
require("core-js/modules/esnext.set.delete-all.js");
require("core-js/modules/esnext.set.difference.js");
require("core-js/modules/esnext.set.every.js");
require("core-js/modules/esnext.set.filter.js");
require("core-js/modules/esnext.set.find.js");
require("core-js/modules/esnext.set.intersection.js");
require("core-js/modules/esnext.set.is-disjoint-from.js");
require("core-js/modules/esnext.set.is-subset-of.js");
require("core-js/modules/esnext.set.is-superset-of.js");
require("core-js/modules/esnext.set.join.js");
require("core-js/modules/esnext.set.map.js");
require("core-js/modules/esnext.set.reduce.js");
require("core-js/modules/esnext.set.some.js");
require("core-js/modules/esnext.set.symmetric-difference.js");
require("core-js/modules/esnext.set.union.js");
var _nodeProcess = _interopRequireDefault(require("node:process"));
var _nodeFs = _interopRequireDefault(require("node:fs"));
var _nodePath = _interopRequireDefault(require("node:path"));
var _index = _interopRequireDefault(require("../@sindresorhus/merge-streams/index.js"));
var _fastGlob = _interopRequireDefault(require("fast-glob"));
var _index2 = require("../path-type/index.js");
var _node = require("../unicorn-magic/node.js");
var _ignore = require("./ignore.js");
var _utilities = require("./utilities.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const assertPatternsInput = patterns => {
  if (patterns.some(pattern => typeof pattern !== 'string')) {
    throw new TypeError('Patterns must be a string or an array of strings');
  }
};
const normalizePathForDirectoryGlob = (filePath, cwd) => {
  const path = (0, _utilities.isNegativePattern)(filePath) ? filePath.slice(1) : filePath;
  return _nodePath.default.isAbsolute(path) ? path : _nodePath.default.join(cwd, path);
};
const getDirectoryGlob = ({
  directoryPath,
  files,
  extensions
}) => {
  const extensionGlob = extensions?.length > 0 ? `.${extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0]}` : '';
  return files ? files.map(file => _nodePath.default.posix.join(directoryPath, `**/${_nodePath.default.extname(file) ? file : `${file}${extensionGlob}`}`)) : [_nodePath.default.posix.join(directoryPath, `**${extensionGlob ? `/*${extensionGlob}` : ''}`)];
};
const directoryToGlob = async (directoryPaths, {
  cwd = _nodeProcess.default.cwd(),
  files,
  extensions
} = {}) => {
  const globs = await Promise.all(directoryPaths.map(async directoryPath => (await (0, _index2.isDirectory)(normalizePathForDirectoryGlob(directoryPath, cwd))) ? getDirectoryGlob({
    directoryPath,
    files,
    extensions
  }) : directoryPath));
  return globs.flat();
};
const directoryToGlobSync = (directoryPaths, {
  cwd = _nodeProcess.default.cwd(),
  files,
  extensions
} = {}) => directoryPaths.flatMap(directoryPath => (0, _index2.isDirectorySync)(normalizePathForDirectoryGlob(directoryPath, cwd)) ? getDirectoryGlob({
  directoryPath,
  files,
  extensions
}) : directoryPath);
const toPatternsArray = patterns => {
  patterns = [...new Set([patterns].flat())];
  assertPatternsInput(patterns);
  return patterns;
};
const checkCwdOption = cwd => {
  if (!cwd) {
    return;
  }
  let stat;
  try {
    stat = _nodeFs.default.statSync(cwd);
  } catch {
    return;
  }
  if (!stat.isDirectory()) {
    throw new Error('The `cwd` option must be a path to a directory');
  }
};
const normalizeOptions = (options = {}) => {
  options = {
    ...options,
    ignore: options.ignore ?? [],
    expandDirectories: options.expandDirectories ?? true,
    cwd: (0, _node.toPath)(options.cwd)
  };
  checkCwdOption(options.cwd);
  return options;
};
const normalizeArguments = function_ => async (patterns, options) => function_(toPatternsArray(patterns), normalizeOptions(options));
const normalizeArgumentsSync = function_ => (patterns, options) => function_(toPatternsArray(patterns), normalizeOptions(options));
const getIgnoreFilesPatterns = options => {
  const {
    ignoreFiles,
    gitignore
  } = options;
  const patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];
  if (gitignore) {
    patterns.push(_ignore.GITIGNORE_FILES_PATTERN);
  }
  return patterns;
};
const getFilter = async options => {
  const ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(ignoreFilesPatterns.length > 0 && (await (0, _ignore.isIgnoredByIgnoreFiles)(ignoreFilesPatterns, options)));
};
const getFilterSync = options => {
  const ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(ignoreFilesPatterns.length > 0 && (0, _ignore.isIgnoredByIgnoreFilesSync)(ignoreFilesPatterns, options));
};
const createFilterFunction = isIgnored => {
  const seen = new Set();
  return fastGlobResult => {
    const pathKey = _nodePath.default.normalize(fastGlobResult.path ?? fastGlobResult);
    if (seen.has(pathKey) || isIgnored && isIgnored(pathKey)) {
      return false;
    }
    seen.add(pathKey);
    return true;
  };
};
const unionFastGlobResults = (results, filter) => results.flat().filter(fastGlobResult => filter(fastGlobResult));
const convertNegativePatterns = (patterns, options) => {
  const tasks = [];
  while (patterns.length > 0) {
    const index = patterns.findIndex(pattern => (0, _utilities.isNegativePattern)(pattern));
    if (index === -1) {
      tasks.push({
        patterns,
        options
      });
      break;
    }
    const ignorePattern = patterns[index].slice(1);
    for (const task of tasks) {
      task.options.ignore.push(ignorePattern);
    }
    if (index !== 0) {
      tasks.push({
        patterns: patterns.slice(0, index),
        options: {
          ...options,
          ignore: [...options.ignore, ignorePattern]
        }
      });
    }
    patterns = patterns.slice(index + 1);
  }
  return tasks;
};
const normalizeExpandDirectoriesOption = (options, cwd) => ({
  ...(cwd ? {
    cwd
  } : {}),
  ...(Array.isArray(options) ? {
    files: options
  } : options)
});
const generateTasks = async (patterns, options) => {
  const globTasks = convertNegativePatterns(patterns, options);
  const {
    cwd,
    expandDirectories
  } = options;
  if (!expandDirectories) {
    return globTasks;
  }
  const directoryToGlobOptions = normalizeExpandDirectoriesOption(expandDirectories, cwd);
  return Promise.all(globTasks.map(async task => {
    let {
      patterns,
      options
    } = task;
    [patterns, options.ignore] = await Promise.all([directoryToGlob(patterns, directoryToGlobOptions), directoryToGlob(options.ignore, {
      cwd
    })]);
    return {
      patterns,
      options
    };
  }));
};
const generateTasksSync = (patterns, options) => {
  const globTasks = convertNegativePatterns(patterns, options);
  const {
    cwd,
    expandDirectories
  } = options;
  if (!expandDirectories) {
    return globTasks;
  }
  const directoryToGlobSyncOptions = normalizeExpandDirectoriesOption(expandDirectories, cwd);
  return globTasks.map(task => {
    let {
      patterns,
      options
    } = task;
    patterns = directoryToGlobSync(patterns, directoryToGlobSyncOptions);
    options.ignore = directoryToGlobSync(options.ignore, {
      cwd
    });
    return {
      patterns,
      options
    };
  });
};
const globby = exports.globby = normalizeArguments(async (patterns, options) => {
  const [tasks, filter] = await Promise.all([generateTasks(patterns, options), getFilter(options)]);
  const results = await Promise.all(tasks.map(task => (0, _fastGlob.default)(task.patterns, task.options)));
  return unionFastGlobResults(results, filter);
});
const globbySync = exports.globbySync = normalizeArgumentsSync((patterns, options) => {
  const tasks = generateTasksSync(patterns, options);
  const filter = getFilterSync(options);
  const results = tasks.map(task => _fastGlob.default.sync(task.patterns, task.options));
  return unionFastGlobResults(results, filter);
});
const globbyStream = exports.globbyStream = normalizeArgumentsSync((patterns, options) => {
  const tasks = generateTasksSync(patterns, options);
  const filter = getFilterSync(options);
  const streams = tasks.map(task => _fastGlob.default.stream(task.patterns, task.options));
  const stream = (0, _index.default)(streams).filter(fastGlobResult => filter(fastGlobResult));

  // TODO: Make it return a web stream at some point.
  // return Readable.toWeb(stream);

  return stream;
});
const isDynamicPattern = exports.isDynamicPattern = normalizeArgumentsSync((patterns, options) => patterns.some(pattern => _fastGlob.default.isDynamicPattern(pattern, options)));
const generateGlobTasks = exports.generateGlobTasks = normalizeArguments(generateTasks);
const generateGlobTasksSync = exports.generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);
const {
  convertPathToPattern
} = _fastGlob.default;
exports.convertPathToPattern = convertPathToPattern;