"use strict";

require("core-js/modules/esnext.weak-map.delete-all.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.firstMatch = firstMatch;
exports.isMatch = isMatch;
exports.matches = matches;
var _index = _interopRequireWildcard(require("../function-timeout/index.js"));
var _index2 = _interopRequireDefault(require("../time-span/index.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const resultToMatch = result => ({
  match: result[0],
  index: result.index,
  groups: result.slice(1),
  namedGroups: result.groups ?? {},
  input: result.input
});
const context = {};
function isMatch(regex, string, {
  timeout
} = {}) {
  try {
    return (0, _index.default)(() => structuredClone(regex).test(string), {
      timeout,
      context
    })();
  } catch (error) {
    if ((0, _index.isTimeoutError)(error)) {
      return false;
    }
    throw error;
  }
}
function firstMatch(regex, string, {
  timeout
} = {}) {
  try {
    const result = (0, _index.default)(() => structuredClone(regex).exec(string), {
      timeout,
      context
    })();
    if (result === null) {
      return;
    }
    return resultToMatch(result);
  } catch (error) {
    if ((0, _index.isTimeoutError)(error)) {
      return;
    }
    throw error;
  }
}
function matches(regex, string, {
  timeout = Number.POSITIVE_INFINITY,
  matchTimeout = Number.POSITIVE_INFINITY
} = {}) {
  if (!regex.global) {
    throw new Error('The regex must have the global flag, otherwise, use `firstMatch()` instead');
  }
  return {
    *[Symbol.iterator]() {
      try {
        const matches = string.matchAll(regex); // The regex is only executed when iterated over.

        while (true) {
          // `matches.next` must be called within an arrow function so that it doesn't loose its context.
          const nextMatch = (0, _index.default)(() => matches.next(), {
            context,
            timeout: timeout !== Number.POSITIVE_INFINITY || matchTimeout !== Number.POSITIVE_INFINITY ? Math.min(timeout, matchTimeout) : undefined
          });
          const end = (0, _index2.default)();
          const {
            value,
            done
          } = nextMatch();
          timeout -= Math.ceil(end());
          if (done) {
            break;
          }
          yield resultToMatch(value);
        }
      } catch (error) {
        if (!(0, _index.isTimeoutError)(error)) {
          throw error;
        }
      }
    }
  };
}