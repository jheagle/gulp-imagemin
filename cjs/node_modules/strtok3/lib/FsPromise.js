"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.close = close;
exports.createReadStream = void 0;
exports.open = open;
exports.pathExists = void 0;
exports.read = read;
exports.readFile = readFile;
exports.stat = stat;
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;
var _nodeFs = _interopRequireDefault(require("node:fs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Module convert fs functions to promise based functions
 */

const pathExists = exports.pathExists = _nodeFs.default.existsSync;
const createReadStream = exports.createReadStream = _nodeFs.default.createReadStream;
async function stat(path) {
  return new Promise((resolve, reject) => {
    _nodeFs.default.stat(path, (err, stats) => {
      if (err) reject(err);else resolve(stats);
    });
  });
}
async function close(fd) {
  return new Promise((resolve, reject) => {
    _nodeFs.default.close(fd, err => {
      if (err) reject(err);else resolve();
    });
  });
}
async function open(path, mode) {
  return new Promise((resolve, reject) => {
    _nodeFs.default.open(path, mode, (err, fd) => {
      if (err) reject(err);else resolve(fd);
    });
  });
}
async function read(fd, buffer, offset, length, position) {
  return new Promise((resolve, reject) => {
    _nodeFs.default.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {
      if (err) reject(err);else resolve({
        bytesRead,
        buffer: _buffer
      });
    });
  });
}
async function writeFile(path, data) {
  return new Promise((resolve, reject) => {
    _nodeFs.default.writeFile(path, data, err => {
      if (err) reject(err);else resolve();
    });
  });
}
function writeFileSync(path, data) {
  _nodeFs.default.writeFileSync(path, data);
}
async function readFile(path) {
  return new Promise((resolve, reject) => {
    _nodeFs.default.readFile(path, (err, buffer) => {
      if (err) reject(err);else resolve(buffer);
    });
  });
}