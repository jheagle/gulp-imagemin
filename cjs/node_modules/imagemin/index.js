"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = imagemin;
require("core-js/modules/esnext.async-iterator.filter.js");
require("core-js/modules/esnext.async-iterator.map.js");
require("core-js/modules/esnext.iterator.constructor.js");
require("core-js/modules/esnext.iterator.filter.js");
require("core-js/modules/esnext.iterator.map.js");
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _nodePath = _interopRequireDefault(require("node:path"));
var _index = require("../file-type/index.js");
var _index2 = require("../globby/index.js");
var _index3 = _interopRequireDefault(require("../p-pipe/index.js"));
var _index4 = _interopRequireDefault(require("../change-file-extension/index.js"));
var _index5 = require("../junk/index.js");
var _index6 = _interopRequireDefault(require("../slash/index.js"));
var _index7 = require("../uint8array-extras/index.js");
var _index8 = require("../environment/index.js");
var _index9 = _interopRequireDefault(require("../ow/dist/index.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const handleFile = async (sourcePath, {
  destination,
  plugins = []
}) => {
  (0, _index9.default)(plugins, _index9.default.optional.array.message('The `plugins` option should be an `Array`'));
  let data = await _promises.default.readFile(sourcePath);
  data = await (plugins.length > 0 ? (0, _index3.default)(...plugins)(data) : data);
  const {
    ext
  } = (await (0, _index.fileTypeFromBuffer)(data)) ?? {
    ext: _nodePath.default.extname(sourcePath)
  };
  let destinationPath = destination ? _nodePath.default.join(destination, _nodePath.default.basename(sourcePath)) : undefined;
  destinationPath = ext === 'webp' ? (0, _index4.default)(destinationPath, 'webp') : destinationPath;
  const returnValue = {
    data: new Uint8Array(data),
    sourcePath,
    destinationPath
  };
  if (!destinationPath) {
    return returnValue;
  }
  await _promises.default.mkdir(_nodePath.default.dirname(returnValue.destinationPath), {
    recursive: true
  });
  await _promises.default.writeFile(returnValue.destinationPath, returnValue.data);
  return returnValue;
};
async function imagemin(input, {
  glob = true,
  ...options
} = {}) {
  if (_index8.isBrowser) {
    throw new Error('This package does not work in the browser.');
  }
  (0, _index9.default)(input, _index9.default.array);
  const unixFilePaths = input.map(path => (0, _index6.default)(path));
  const filePaths = glob ? await (0, _index2.globby)(unixFilePaths, {
    onlyFiles: true
  }) : input;
  return Promise.all(filePaths.filter(filePath => (0, _index5.isNotJunk)(_nodePath.default.basename(filePath))).map(async filePath => {
    try {
      return await handleFile(filePath, options);
    } catch (error) {
      error.message = `Error occurred when handling file: ${input}\n\n${error.stack}`;
      throw error;
    }
  }));
}
imagemin.buffer = async (data, {
  plugins = []
} = {}) => {
  if (_index8.isBrowser) {
    throw new Error('This package does not work in the browser.');
  }
  (0, _index7.assertUint8Array)(data);
  if (plugins.length === 0) {
    return new Uint8Array(data);
  }

  // The `new Uint8Array` can be removed if all plugins are changed to return `Uint8Array` instead of `Buffer`.
  return new Uint8Array(await (0, _index3.default)(...plugins)(data));
};