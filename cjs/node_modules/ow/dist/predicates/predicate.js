"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validatorSymbol = exports.Predicate = void 0;
require("core-js/modules/esnext.map.delete-all.js");
require("core-js/modules/esnext.map.every.js");
require("core-js/modules/esnext.map.filter.js");
require("core-js/modules/esnext.map.find.js");
require("core-js/modules/esnext.map.find-key.js");
require("core-js/modules/esnext.map.includes.js");
require("core-js/modules/esnext.map.key-of.js");
require("core-js/modules/esnext.map.map-keys.js");
require("core-js/modules/esnext.map.map-values.js");
require("core-js/modules/esnext.map.merge.js");
require("core-js/modules/esnext.map.reduce.js");
require("core-js/modules/esnext.map.some.js");
require("core-js/modules/esnext.map.update.js");
require("core-js/modules/esnext.set.add-all.js");
require("core-js/modules/esnext.set.delete-all.js");
require("core-js/modules/esnext.set.difference.js");
require("core-js/modules/esnext.set.every.js");
require("core-js/modules/esnext.set.filter.js");
require("core-js/modules/esnext.set.find.js");
require("core-js/modules/esnext.set.intersection.js");
require("core-js/modules/esnext.set.is-disjoint-from.js");
require("core-js/modules/esnext.set.is-subset-of.js");
require("core-js/modules/esnext.set.is-superset-of.js");
require("core-js/modules/esnext.set.join.js");
require("core-js/modules/esnext.set.map.js");
require("core-js/modules/esnext.set.reduce.js");
require("core-js/modules/esnext.set.some.js");
require("core-js/modules/esnext.set.symmetric-difference.js");
require("core-js/modules/esnext.set.union.js");
require("core-js/modules/esnext.string.at.js");
var _index = _interopRequireDefault(require("../../../@sindresorhus/is/dist/index.js"));
var _argumentError = require("../argument-error.js");
var _not = require("../operators/not.js");
var _generateArgumentErrorMessage = require("../utils/generate-argument-error-message.js");
var _basePredicate = require("./base-predicate.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
@hidden
*/
const validatorSymbol = exports.validatorSymbol = Symbol('validators');
/**
@hidden
*/
class Predicate {
  type;
  options;
  context = {
    validators: []
  };
  constructor(type, options = {}) {
    this.type = type;
    this.options = options;
    this.context = {
      ...this.context,
      ...this.options
    };
    const typeString = this.type.charAt(0).toLowerCase() + this.type.slice(1);
    this.addValidator({
      message: (value, label) => {
        // We do not include type in this label as we do for other messages, because it would be redundant.
        const label_ = label?.slice(this.type.length + 1);
        // TODO: The NaN check can be removed when `@sindresorhus/is` is fixed: https://github.com/sindresorhus/ow/issues/231#issuecomment-1047100612
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return `Expected ${label_ || 'argument'} to be of type \`${this.type}\` but received type \`${Number.isNaN(value) ? 'NaN' : (0, _index.default)(value)}\``;
      },
      // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      validator: value => _index.default[typeString](value)
    });
  }
  /**
  @hidden
  */
  [_basePredicate.testSymbol](value, main, label, idLabel) {
    // Create a map of labels -> received errors.
    const errors = new Map();
    for (const {
      validator,
      message
    } of this.context.validators) {
      if (this.options.optional === true && value === undefined) {
        continue;
      }
      let result;
      try {
        result = validator(value);
      } catch (error) {
        // Any errors caught means validators couldn't process the input.
        result = error;
      }
      if (result === true) {
        continue;
      }
      const label2 = _index.default.function_(label) ? label() : label;
      const labelWithTick = label2 && idLabel ? `\`${label2}\`` : label2;
      const label_ = labelWithTick ? `${this.type} ${labelWithTick}` : this.type;
      const mapKey = label2 || this.type;
      // Get the current errors encountered for this label.
      const currentErrors = errors.get(mapKey);
      // Pre-generate the error message that will be reported to the user.
      const errorMessage = message(value, label_, result);
      // If we already have any errors for this label.
      if (currentErrors) {
        // If we don't already have this error logged, add it.
        currentErrors.add(errorMessage);
      } else {
        // Set this label and error in the full map.
        errors.set(mapKey, new Set([errorMessage]));
      }
    }
    // If we have any errors to report, throw.
    if (errors.size > 0) {
      // Generate the `error.message` property.
      const message = (0, _generateArgumentErrorMessage.generateArgumentErrorMessage)(errors);
      throw new _argumentError.ArgumentError(message, main, errors);
    }
  }
  /**
  @hidden
  */
  get [validatorSymbol]() {
    return this.context.validators;
  }
  /**
  Invert the following validators.
  */
  get not() {
    return (0, _not.not)(this);
  }
  /**
  Test if the value matches a custom validation function. The validation function should return an object containing a `validator` and `message`. If the `validator` is `false`, the validation fails and the `message` will be used as error message. If the `message` is a function, the function is invoked with the `label` as argument to let you further customize the error message.
   @param customValidator - Custom validation function.
  */
  validate(customValidator) {
    return this.addValidator({
      message: (_, label, error) => typeof error === 'string' ? `(${label}) ${error}`
      // eslint-disable-next-line @typescript-eslint/no-unsafe-call
      : error(label),
      validator(value) {
        const {
          message,
          validator
        } = customValidator(value);
        if (validator) {
          return true;
        }
        return message;
      }
    });
  }
  /**
  Test if the value matches a custom validation function. The validation function should return `true` if the value passes the function. If the function either returns `false` or a string, the function fails and the string will be used as error message.
   @param validator - Validation function.
  */
  is(validator) {
    return this.addValidator({
      message: (value, label, error) => error ? `(${label}) ${error}` : `Expected ${label} \`${value}\` to pass custom validation function`,
      validator
    });
  }
  /**
  Provide a new error message to be thrown when the validation fails.
   @param newMessage - Either a string containing the new message or a function returning the new message.
   @example
  ```
  ow('ðŸŒˆ', 'unicorn', ow.string.equals('ðŸ¦„').message('Expected unicorn, got rainbow'));
  //=> ArgumentError: Expected unicorn, got rainbow
  ```
   @example
  ```
  ow('ðŸŒˆ', ow.string.minLength(5).message((value, label) => `Expected ${label}, to have a minimum length of 5, got \`${value}\``));
  //=> ArgumentError: Expected string, to be have a minimum length of 5, got `ðŸŒˆ`
  ```
  */
  message(newMessage) {
    const {
      validators
    } = this.context;
    validators.at(-1).message = (value, label) => {
      if (typeof newMessage === 'function') {
        return newMessage(value, label);
      }
      return newMessage;
    };
    return this;
  }
  /**
  Register a new validator.
   @param validator - Validator to register.
  */
  addValidator(validator) {
    this.context.validators.push(validator);
    return this;
  }
}
exports.Predicate = Predicate;