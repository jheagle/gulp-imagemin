"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnyPredicate = void 0;
require("core-js/modules/esnext.map.delete-all.js");
require("core-js/modules/esnext.map.every.js");
require("core-js/modules/esnext.map.filter.js");
require("core-js/modules/esnext.map.find.js");
require("core-js/modules/esnext.map.find-key.js");
require("core-js/modules/esnext.map.includes.js");
require("core-js/modules/esnext.map.key-of.js");
require("core-js/modules/esnext.map.map-keys.js");
require("core-js/modules/esnext.map.map-values.js");
require("core-js/modules/esnext.map.merge.js");
require("core-js/modules/esnext.map.reduce.js");
require("core-js/modules/esnext.map.some.js");
require("core-js/modules/esnext.map.update.js");
require("core-js/modules/esnext.set.add-all.js");
require("core-js/modules/esnext.set.delete-all.js");
require("core-js/modules/esnext.set.difference.js");
require("core-js/modules/esnext.set.every.js");
require("core-js/modules/esnext.set.filter.js");
require("core-js/modules/esnext.set.find.js");
require("core-js/modules/esnext.set.intersection.js");
require("core-js/modules/esnext.set.is-disjoint-from.js");
require("core-js/modules/esnext.set.is-subset-of.js");
require("core-js/modules/esnext.set.is-superset-of.js");
require("core-js/modules/esnext.set.join.js");
require("core-js/modules/esnext.set.map.js");
require("core-js/modules/esnext.set.reduce.js");
require("core-js/modules/esnext.set.some.js");
require("core-js/modules/esnext.set.symmetric-difference.js");
require("core-js/modules/esnext.set.union.js");
var _argumentError = require("../argument-error.js");
var _generateArgumentErrorMessage = require("../utils/generate-argument-error-message.js");
var _basePredicate = require("./base-predicate.js");
/**
@hidden
*/
class AnyPredicate {
  predicates;
  options;
  constructor(predicates, options = {}) {
    this.predicates = predicates;
    this.options = options;
  }
  [_basePredicate.testSymbol](value, main, label, idLabel) {
    const errors = new Map();
    for (const predicate of this.predicates) {
      try {
        main(value, label, predicate, idLabel);
        return;
      } catch (error) {
        if (value === undefined && this.options.optional === true) {
          return;
        }
        // If we received an ArgumentError, then..
        if (error instanceof _argumentError.ArgumentError) {
          // Iterate through every error reported.
          for (const [key, value] of error.validationErrors.entries()) {
            // Get the current errors set, if any.
            const alreadyPresent = errors.get(key);
            // Add all errors under the same key
            errors.set(key, new Set([...(alreadyPresent ?? []), ...value]));
          }
        }
      }
    }
    if (errors.size > 0) {
      // Generate the `error.message` property.
      const message = (0, _generateArgumentErrorMessage.generateArgumentErrorMessage)(errors, true);
      throw new _argumentError.ArgumentError(`Any predicate failed with the following errors:\n${message}`, main, errors);
    }
  }
}
exports.AnyPredicate = AnyPredicate;