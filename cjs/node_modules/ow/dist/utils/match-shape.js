"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exact = exact;
exports.partial = partial;
require("core-js/modules/esnext.set.add-all.js");
require("core-js/modules/esnext.set.delete-all.js");
require("core-js/modules/esnext.set.difference.js");
require("core-js/modules/esnext.set.every.js");
require("core-js/modules/esnext.set.filter.js");
require("core-js/modules/esnext.set.find.js");
require("core-js/modules/esnext.set.intersection.js");
require("core-js/modules/esnext.set.is-disjoint-from.js");
require("core-js/modules/esnext.set.is-subset-of.js");
require("core-js/modules/esnext.set.is-superset-of.js");
require("core-js/modules/esnext.set.join.js");
require("core-js/modules/esnext.set.map.js");
require("core-js/modules/esnext.set.reduce.js");
require("core-js/modules/esnext.set.some.js");
require("core-js/modules/esnext.set.symmetric-difference.js");
require("core-js/modules/esnext.set.union.js");
var _index = _interopRequireDefault(require("../../../@sindresorhus/is/dist/index.js"));
var _test = _interopRequireDefault(require("../test.js"));
var _basePredicate = require("../predicates/base-predicate.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
Test if the `object` matches the `shape` partially.

@hidden

@param object - Object to test against the provided shape.
@param shape - Shape to test the object against.
@param parent - Name of the parent property.
*/
function partial(object, shape, parent) {
  try {
    for (const key of Object.keys(shape)) {
      const label = parent ? `${parent}.${key}` : key;
      if ((0, _basePredicate.isPredicate)(shape[key])) {
        (0, _test.default)(object[key], label, shape[key]);
      } else if (_index.default.plainObject(shape[key])) {
        const result = partial(object[key], shape[key], label);
        if (result !== true) {
          return result;
        }
      }
    }
    return true;
  } catch (error) {
    return error.message;
  }
}
/**
Test if the `object` matches the `shape` exactly.

@hidden

@param object - Object to test against the provided shape.
@param shape - Shape to test the object against.
@param parent - Name of the parent property.
*/
function exact(object, shape, parent, isArray) {
  try {
    const objectKeys = new Set(Object.keys(object));
    for (const key of Object.keys(shape)) {
      objectKeys.delete(key);
      const label = parent ? `${parent}.${key}` : key;
      if ((0, _basePredicate.isPredicate)(shape[key])) {
        (0, _test.default)(object[key], label, shape[key]);
      } else if (_index.default.plainObject(shape[key])) {
        if (!Object.hasOwn(object, key)) {
          return `Expected \`${label}\` to exist`;
        }
        const result = exact(object[key], shape[key], label);
        if (result !== true) {
          return result;
        }
      }
    }
    if (objectKeys.size > 0) {
      const firstKey = [...objectKeys.keys()][0];
      const label = parent ? `${parent}.${firstKey}` : firstKey;
      return `Did not expect ${isArray ? 'element' : 'property'} \`${label}\` to exist, got \`${object[firstKey]}\``;
    }
    return true;
  } catch (error) {
    return error.message;
  }
}