"use strict";

require("core-js/modules/esnext.weak-map.delete-all.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeAllStream = exports.handleInputSync = exports.handleInput = exports.getSpawnedResult = void 0;
var _nodeFs = require("node:fs");
var _promises = require("node:timers/promises");
var _index = require("../../is-stream/index.js");
var _index2 = _interopRequireWildcard(require("../../get-stream/source/index.js"));
var _mergeStream = _interopRequireDefault(require("merge-stream"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const validateInputOptions = input => {
  if (input !== undefined) {
    throw new TypeError('The `input` and `inputFile` options cannot be both set.');
  }
};
const getInputSync = ({
  input,
  inputFile
}) => {
  if (typeof inputFile !== 'string') {
    return input;
  }
  validateInputOptions(input);
  return (0, _nodeFs.readFileSync)(inputFile);
};

// `input` and `inputFile` option in sync mode
const handleInputSync = options => {
  const input = getInputSync(options);
  if ((0, _index.isStream)(input)) {
    throw new TypeError('The `input` option cannot be a stream in sync mode');
  }
  return input;
};
exports.handleInputSync = handleInputSync;
const getInput = ({
  input,
  inputFile
}) => {
  if (typeof inputFile !== 'string') {
    return input;
  }
  validateInputOptions(input);
  return (0, _nodeFs.createReadStream)(inputFile);
};

// `input` and `inputFile` option in async mode
const handleInput = (spawned, options) => {
  const input = getInput(options);
  if (input === undefined) {
    return;
  }
  if ((0, _index.isStream)(input)) {
    input.pipe(spawned.stdin);
  } else {
    spawned.stdin.end(input);
  }
};

// `all` interleaves `stdout` and `stderr`
exports.handleInput = handleInput;
const makeAllStream = (spawned, {
  all
}) => {
  if (!all || !spawned.stdout && !spawned.stderr) {
    return;
  }
  const mixed = (0, _mergeStream.default)();
  if (spawned.stdout) {
    mixed.add(spawned.stdout);
  }
  if (spawned.stderr) {
    mixed.add(spawned.stderr);
  }
  return mixed;
};

// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
exports.makeAllStream = makeAllStream;
const getBufferedData = async (stream, streamPromise) => {
  // When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve
  if (!stream || streamPromise === undefined) {
    return;
  }

  // Wait for the `all` stream to receive the last chunk before destroying the stream
  await (0, _promises.setTimeout)(0);
  stream.destroy();
  try {
    return await streamPromise;
  } catch (error) {
    return error.bufferedData;
  }
};
const getStreamPromise = (stream, {
  encoding,
  buffer,
  maxBuffer
}) => {
  if (!stream || !buffer) {
    return;
  }

  // eslint-disable-next-line unicorn/text-encoding-identifier-case
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return (0, _index2.default)(stream, {
      maxBuffer
    });
  }
  if (encoding === null || encoding === 'buffer') {
    return (0, _index2.getStreamAsBuffer)(stream, {
      maxBuffer
    });
  }
  return applyEncoding(stream, maxBuffer, encoding);
};
const applyEncoding = async (stream, maxBuffer, encoding) => {
  const buffer = await (0, _index2.getStreamAsBuffer)(stream, {
    maxBuffer
  });
  return buffer.toString(encoding);
};

// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
const getSpawnedResult = async ({
  stdout,
  stderr,
  all
}, {
  encoding,
  buffer,
  maxBuffer
}, processDone) => {
  const stdoutPromise = getStreamPromise(stdout, {
    encoding,
    buffer,
    maxBuffer
  });
  const stderrPromise = getStreamPromise(stderr, {
    encoding,
    buffer,
    maxBuffer
  });
  const allPromise = getStreamPromise(all, {
    encoding,
    buffer,
    maxBuffer: maxBuffer * 2
  });
  try {
    return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
  } catch (error) {
    return Promise.all([{
      error,
      signal: error.signal,
      timedOut: error.timedOut
    }, getBufferedData(stdout, stdoutPromise), getBufferedData(stderr, stderrPromise), getBufferedData(all, allPromise)]);
  }
};
exports.getSpawnedResult = getSpawnedResult;