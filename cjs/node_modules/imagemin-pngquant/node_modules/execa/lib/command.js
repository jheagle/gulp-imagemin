"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTemplates = exports.parseCommand = exports.joinCommand = exports.getEscapedCommand = void 0;
require("core-js/modules/esnext.async-iterator.filter.js");
require("core-js/modules/esnext.async-iterator.map.js");
require("core-js/modules/esnext.iterator.constructor.js");
require("core-js/modules/esnext.iterator.filter.js");
require("core-js/modules/esnext.iterator.map.js");
require("core-js/modules/esnext.string.at.js");
var _nodeBuffer = require("node:buffer");
var _nodeChild_process = require("node:child_process");
const normalizeArgs = (file, args = []) => {
  if (!Array.isArray(args)) {
    return [file];
  }
  return [file, ...args];
};
const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
const escapeArg = arg => {
  if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
    return arg;
  }
  return `"${arg.replaceAll('"', '\\"')}"`;
};
const joinCommand = (file, args) => normalizeArgs(file, args).join(' ');
exports.joinCommand = joinCommand;
const getEscapedCommand = (file, args) => normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');
exports.getEscapedCommand = getEscapedCommand;
const SPACES_REGEXP = / +/g;

// Handle `execaCommand()`
const parseCommand = command => {
  const tokens = [];
  for (const token of command.trim().split(SPACES_REGEXP)) {
    // Allow spaces to be escaped by a backslash if not meant as a delimiter
    const previousToken = tokens.at(-1);
    if (previousToken && previousToken.endsWith('\\')) {
      // Merge previous token with current one
      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
    } else {
      tokens.push(token);
    }
  }
  return tokens;
};
exports.parseCommand = parseCommand;
const parseExpression = expression => {
  const typeOfExpression = typeof expression;
  if (typeOfExpression === 'string') {
    return expression;
  }
  if (typeOfExpression === 'number') {
    return String(expression);
  }
  if (typeOfExpression === 'object' && expression !== null && !(expression instanceof _nodeChild_process.ChildProcess) && 'stdout' in expression) {
    const typeOfStdout = typeof expression.stdout;
    if (typeOfStdout === 'string') {
      return expression.stdout;
    }
    if (_nodeBuffer.Buffer.isBuffer(expression.stdout)) {
      return expression.stdout.toString();
    }
    throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
const concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [...tokens.slice(0, -1), `${tokens.at(-1)}${nextTokens[0]}`, ...nextTokens.slice(1)];
const parseTemplate = ({
  templates,
  expressions,
  tokens,
  index,
  template
}) => {
  const templateString = template ?? templates.raw[index];
  const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
  const newTokens = concatTokens(tokens, templateTokens, templateString.startsWith(' '));
  if (index === expressions.length) {
    return newTokens;
  }
  const expression = expressions[index];
  const expressionTokens = Array.isArray(expression) ? expression.map(expression => parseExpression(expression)) : [parseExpression(expression)];
  return concatTokens(newTokens, expressionTokens, templateString.endsWith(' '));
};
const parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (const [index, template] of templates.entries()) {
    tokens = parseTemplate({
      templates,
      expressions,
      tokens,
      index,
      template
    });
  }
  return tokens;
};
exports.parseTemplates = parseTemplates;